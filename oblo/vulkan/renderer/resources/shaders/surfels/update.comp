#version 460

#extension GL_GOOGLE_include_directive : require

#include <renderer/debug/printf>
#include <surfels/buffers/surfel_grid_rw>
#include <surfels/buffers/surfel_pool_r>
#include <surfels/surfel>
#include <surfels/surfel_data>

layout(local_size_x = OBLO_SUBGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform c_PushConstants
{
    uint maxSurfels;
}
g_Constants;

void main()
{
    const uint surfelId = gl_GlobalInvocationID.x;

    if (surfelId >= g_Constants.maxSurfels)
    {
        return;
    }

    const surfel_data surfel = g_SurfelData[surfelId];

    if (!surfel_data_is_alive(surfel))
    {
        return;
    }

    // debugPrintfEXT("[UPDATE] Surfel alive: %u", surfelId);

    const vec3 wsPos = surfel_data_world_position(surfel);

    const surfel_grid_header gridHeader = g_SurfelGridHeader;

    const ivec3 cell = surfel_grid_find_cell(gridHeader, wsPos);

    if (!surfel_grid_has_cell(gridHeader, cell))
    {
        return;
    }

    const uint cellIndex = surfel_grid_cell_index(gridHeader, cell);

    const uint newIndex = atomicAdd(g_SurfelGridCells[cellIndex].surfelsCount, 1);

    if (newIndex >= SURFEL_MAX_PER_CELL)
    {
        // We already have the maximum amount of surfels per grid
        printf_uvec3("[UPDATE] Overflowing cell: ", cell);
        return;
    }

    // debugPrintfEXT("[UPDATE] Surfel %u alive: %u\n", surfelId, uint(surfel.alive));
    // debugPrintfEXT("[UPDATE] Fill cell: %u\n", cell);
    // debugPrintfEXT("[UPDATE] Current surfels in cell: %u\n", newIndex);

    // debugPrintfEXT("Fill cell: [ %d %d %d ] (%u) with %u\n", cell.x, cell.y, cell.z, cellIndex, surfelId);

    g_SurfelGridCells[cellIndex].surfels[newIndex] = surfelId;
}