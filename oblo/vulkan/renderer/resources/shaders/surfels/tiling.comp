#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_buffer_reference : require
#extension GL_ARB_gpu_shader_int64 : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_control_flow_attributes : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_ballot : require

#include <ecs/entity_buffer>
#include <renderer/debug/printf>
#include <renderer/instances>
#include <renderer/math>
#include <renderer/meshes/mesh_attributes>
#include <renderer/meshes/mesh_data>
#include <renderer/meshes/mesh_indices>
#include <renderer/meshes/mesh_table>
#include <renderer/transform>
#include <surfels/buffers/surfel_data_r>
#include <surfels/buffers/surfel_grid_r>
#include <surfels/reduction>
#include <surfels/surfel>
#include <visibility/visibility_buffer>
#include <visibility/visibility_utils>

const uint g_TileSize = OBLO_SUBGROUP_SIZE;

layout(std430, binding = 0) restrict writeonly buffer b_OutTileCoverage
{
    surfel_tile_data g_TileData[];
};

layout(binding = 10, rg32ui) uniform restrict readonly uimage2D t_InVisibilityBuffer;

layout(binding = 16) uniform b_CameraBuffer
{
    camera_buffer g_Camera;
};

layout(local_size_x = g_TileSize, local_size_y = g_TileSize, local_size_z = 1) in;

bool read_spawn_data(in ivec2 screenPos, in uvec2 resolution, out surfel_spawn_data spawnData, out vec3 positionWS);

uint count_pixels_with_fragments(in bool hasFragment)
{
    const uvec4 hasFragmentBallot = subgroupBallot(hasFragment);
    return subgroupBallotBitCount(hasFragmentBallot);
}

shared surfel_tile_data g_GroupCandidates[OBLO_SUBGROUP_SIZE * OBLO_SUBGROUP_SIZE];

// shared surfel_tile_data g_GroupCandidates[OBLO_SUBGROUP_SIZE];
shared uint g_PixelsWithFragments[OBLO_SUBGROUP_SIZE];
shared float g_WeightSums[OBLO_SUBGROUP_SIZE];

void main()
{
    const ivec2 screenPos = ivec2(gl_WorkGroupID.xy * gl_WorkGroupSize.xy + gl_LocalInvocationID.xy);
    const uvec2 resolution = imageSize(t_InVisibilityBuffer);

    const bool outOfScreenBounds = screenPos.x >= resolution.x || screenPos.y >= resolution.y;

    // When nothing is in the visibility buffer, we will fall back to the skybox. These pixels should not really matter
    // for the coverage, for now we assign an arbitrary coverage though.
    float weightSum = 0;
    vec3 positionWS;

    surfel_spawn_data spawnData;
    const bool hasGeometry = !outOfScreenBounds && read_spawn_data(screenPos, resolution, spawnData, positionWS);

    if (hasGeometry)
    {
        const surfel_grid_header gridHeader = g_SurfelGridHeader;

        const ivec3 cell = surfel_grid_find_cell(gridHeader, positionWS);

        // Search neighboring cells and accumulate overlapping surfels
        [[unroll]] for (int x = -1; x <= 1; ++x)
        {
            [[unroll]] for (int y = -1; y <= 1; ++y)
            {
                [[unroll]] for (int z = -1; z <= 1; ++z)
                {
                    const ivec3 current = cell + ivec3(x, y, z);

                    if (surfel_grid_has_cell(gridHeader, current))
                    {
                        const uint cellIndex = surfel_grid_cell_index(gridHeader, current);
                        const surfel_grid_cell cellData = g_SurfelGridCells[cellIndex];

                        // We could consider adding some weight for the number of surfels in the same cell, to
                        // prioritize tiles that don't have any
                        const uint surfelsCount = min(cellData.surfelsCount, SURFEL_MAX_PER_CELL);

                        for (uint cellSurfelIndex = 0; cellSurfelIndex < surfelsCount; ++cellSurfelIndex)
                        {
                            const uint surfelId = cellData.surfels[cellSurfelIndex];

                            const surfel_data surfel = g_SurfelData[surfelId];

                            // We should instead probably weigh by distance, but for now we just add 1 if it's in range
                            weightSum += surfel_weight(surfel, positionWS);
                        }
                    }
                }
            }
        }
    }
    else
    {
        spawnData = surfel_spawn_data_invalid();
    }

#if 1

    surfel_tile_data tileData;
    tileData.worstPixelCoverage = hasGeometry ? weightSum : NO_SURFELS_NEEDED;
    tileData.spawnData = spawnData;

    g_GroupCandidates[gl_WorkGroupID.y * gl_WorkGroupSize.x + gl_WorkGroupID.x] = tileData;

    memoryBarrierShared();
    barrier();

    if (gl_LocalInvocationID.xy == uvec2(0, 0))
    {
        float sum = 0;
        uint pixels = 0;
        uint current = 0;

        surfel_tile_data candidate = g_GroupCandidates[current];

        for (uint i = 1; i < OBLO_SUBGROUP_SIZE * OBLO_SUBGROUP_SIZE; ++i)
        {
            surfel_tile_data newCandidate = g_GroupCandidates[i];

            if (newCandidate.worstPixelCoverage < NO_SURFELS_NEEDED)
            {
                sum += newCandidate.worstPixelCoverage;
                ++pixels;
            }

            // pixels += uint(newCandidate.worstPixelCoverage < NO_SURFELS_NEEDED);

            if (newCandidate.worstPixelCoverage < candidate.worstPixelCoverage)
            {
                candidate = newCandidate;
                current = i;
            }
        }

        const uint globalIndex = gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.x;

        if (candidate.worstPixelCoverage == NO_SURFELS_NEEDED)
        {
            tileData.spawnData = surfel_spawn_data_invalid();
            tileData.averageTileCoverage = NO_SURFELS_NEEDED;
        }
        else
        {
            tileData.averageTileCoverage = sum / pixels;
        }

        g_TileData[globalIndex] = tileData;
    }
#else

    // const uint pixelsWithFragments = count_pixels_with_fragments(hasGeometry);
    uint pixelsWithFragments = 0;
    float subgroupWeightSum = 0;

    const bool hasGeometryData = ecs_entity_is_valid(spawnData.entity);

    if (hasGeometryData)
    {
        // Only perform the sum on pixels with geometry
        // Inactive threads in the dynamic branch will be ignored
        // TODO: Does it matter? The others should be 0
        subgroupWeightSum = subgroupAdd(weightSum);
        pixelsWithFragments = subgroupAdd(1);
    }

    const float pixelCoverage = hasGeometryData ? weightSum : NO_SURFELS_NEEDED;
    const uint bestSubgroupCandidateIdx = find_lowest_within_subgroup(pixelCoverage);

    // if (gl_WorkGroupID.xy == uvec2(0))
    // {
    //     const uint localOutputIndex2 =
    //         (OBLO_SUBGROUP_SIZE * gl_LocalInvocationID.y + gl_LocalInvocationID.x) / OBLO_SUBGROUP_SIZE;

    // #if OBLO_DEBUG_PRINTF
    //     debugPrintfEXT("[TILING] [pixel: %d %d] [wg: %d %d] [lid: %d %d] [%d %d] %d\n",
    //         screenPos.x,
    //         screenPos.y,
    //         gl_WorkGroupID.x,
    //         gl_WorkGroupID.y,
    //         gl_LocalInvocationID.x,
    //         gl_LocalInvocationID.y,
    //         gl_SubgroupID,
    //         gl_SubgroupInvocationID,
    //         localOutputIndex2);
    // #endif
    // }

    if (gl_SubgroupInvocationID == bestSubgroupCandidateIdx)
    {
        surfel_tile_data tileData;
        tileData.worstPixelCoverage = pixelCoverage;
        tileData.spawnData = spawnData;

        debug_assert(tileData.worstPixelCoverage != NO_SURFELS_NEEDED || !ecs_entity_is_valid(spawnData.entity));
        // debug_assert(
        //     !ecs_entity_is_valid(tileData.spawnData.entity) || tileData.worstPixelCoverage == NO_SURFELS_NEEDED);

        if (!ecs_entity_is_valid(tileData.spawnData.entity) && tileData.worstPixelCoverage != NO_SURFELS_NEEDED)
        {
    #if OBLO_DEBUG_PRINTF
            debugPrintfEXT("[TILING] (Before) Entity: %d -> %f \n",
                tileData.spawnData.entity.id,
                tileData.worstPixelCoverage);
    #endif
        }

        const uint localOutputIndex = gl_SubgroupID;
        g_GroupCandidates[localOutputIndex] = tileData;
        g_PixelsWithFragments[localOutputIndex] = pixelsWithFragments;
        g_WeightSums[localOutputIndex] = subgroupWeightSum;

        // #if OBLO_DEBUG_PRINTF
        //     debugPrintfEXT("[TILING] [pixel: %d %d] [wg: %d %d] [lid: %d %d] [%d %d]\n",
        //         screenPos.x,
        //         screenPos.y,
        //         gl_WorkGroupID.x,
        //         gl_WorkGroupID.y,
        //         gl_LocalInvocationID.x,
        //         gl_LocalInvocationID.y,
        //         gl_SubgroupID,
        //         gl_SubgroupInvocationID);
        // #endif
    }

    subgroupMemoryBarrierShared();
    subgroupBarrier();

    memoryBarrierShared();
    barrier();

    // We only keep the first subgroup active now, to perform another round of reduction
    if (gl_SubgroupID > 0)
    {
        return;
    }

    surfel_tile_data tileData = g_GroupCandidates[gl_SubgroupInvocationID];
    const uint pixelWithFragmentsWholeSubgroup = g_PixelsWithFragments[gl_SubgroupInvocationID];
    const float weightSumWholeSubgroup = g_WeightSums[gl_SubgroupInvocationID];

    debug_assert(ecs_entity_is_valid(tileData.spawnData.entity) || tileData.worstPixelCoverage == NO_SURFELS_NEEDED);

    if (!ecs_entity_is_valid(tileData.spawnData.entity) && tileData.worstPixelCoverage != NO_SURFELS_NEEDED)
    {
    #if OBLO_DEBUG_PRINTF
        debugPrintfEXT("[TILING] (After) Entity: %d -> %f \n",
            tileData.spawnData.entity.id,
            tileData.worstPixelCoverage);
    #endif
    }

    // #if OBLO_DEBUG_PRINTF
    //     if (tileData.spawnData.entity.id > 3)
    //     {
    //         debugPrintfEXT("[TILING] Entity: %d [%d %d %d %d] \n",
    //             tileData.spawnData.entity.id,
    //             gl_WorkGroupID.x,
    //             gl_WorkGroupID.y,
    //             gl_SubgroupID,
    //             gl_SubgroupInvocationID);
    //     }
    // #endif

    subgroupMemoryBarrierShared();
    subgroupBarrier();

    // const uint bestWorkGroupCandidateIdx = find_lowest_within_subgroup(tileData.worstPixelCoverage);
    const uint bestWorkGroupCandidateIdx = find_lowest_within_subgroup(tileData.worstPixelCoverage);

    const uint totalPixelsWithFragments = subgroupAdd(pixelWithFragmentsWholeSubgroup);
    float totalWeightSum = NO_SURFELS_NEEDED;

    if (pixelWithFragmentsWholeSubgroup > 0)
    {
        totalWeightSum = subgroupAdd(weightSumWholeSubgroup);
    }

    if (gl_SubgroupInvocationID == bestWorkGroupCandidateIdx)
    {
        const uint globalIndex = gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.x;

        if (totalPixelsWithFragments == 0 || !ecs_entity_is_valid(tileData.spawnData.entity))
        {
            tileData.averageTileCoverage = NO_SURFELS_NEEDED;
            tileData.worstPixelCoverage = NO_SURFELS_NEEDED;
            tileData.spawnData = surfel_spawn_data_invalid();
        }
        else
        {
            tileData.averageTileCoverage = totalWeightSum / totalPixelsWithFragments;
        }

        g_TileData[globalIndex] = tileData;

        if (!ecs_entity_is_valid(tileData.spawnData.entity) && tileData.averageTileCoverage != NO_SURFELS_NEEDED)
        {
    #if OBLO_DEBUG_PRINTF
            debugPrintfEXT("[TILING] (Final) Entity: %d -> %f \n",
                tileData.spawnData.entity.id,
                tileData.averageTileCoverage);
    #endif
        }

        // #if OBLO_DEBUG_PRINTF
        //     if (tileData.spawnData.entity.id != 0)
        //     {
        //         debugPrintfEXT("[TILING] Output[%d]: [entity: %d] [triangle: %d %f %f] [coverage: %f]\n",
        //             globalIndex,
        //             tileData.spawnData.entity.id,
        //             tileData.spawnData.packedMeshletAndTriangleId,
        //             tileData.spawnData.barycentricU,
        //             tileData.spawnData.barycentricV,
        //             tileData.worstPixelCoverage);
        //     }
        // #endif
    }

#endif
}

bool read_spawn_data(in ivec2 screenPos, in uvec2 resolution, out surfel_spawn_data spawnData, out vec3 positionWS)
{
    // Parse the visibility buffer to find which triangle we are processing
    const uvec4 visBufferData = imageLoad(t_InVisibilityBuffer, screenPos);

    visibility_buffer_data vb;

    if (!visibility_buffer_parse(visBufferData.xy, vb))
    {
        return false;
    }

    // Read the instance data we need
    const mesh_handle mesh = OBLO_INSTANCE_DATA(vb.instanceTableId, i_MeshHandles, vb.instanceId);
    const transform transform = OBLO_INSTANCE_DATA(vb.instanceTableId, i_TransformBuffer, vb.instanceId);

    triangle triangleWS;

    // Read the mesh data
    const mesh_table meshTable = mesh_table_fetch(mesh);
    const uvec3 vertexIndices = mesh_get_meshlet_indices(meshTable, mesh, vb.meshletId, vb.meshletTriangleId);

    // Read the vertex data and transform everything in world space, we do lighting calculation in that space
    [[unroll]] for (uint i = 0; i < 3; ++i)
    {
        const uint vertexId = vertexIndices[i];

        const vec3 vertexPosition = mesh_get_position(meshTable, vertexId);
        triangleWS.v[i] = (transform.localToWorld * vec4(vertexPosition, 1)).xyz;
    }

    barycentric_coords bc;

    // Cast a ray from the camera to the near plane and calculate the distance of the ray hit to the plane on the
    // triangle in world space, we use that to derive the position in world space
    const vec2 ndc = screen_to_ndc(screenPos, resolution);
    const ray cameraRay = visibility_calculate_camera_ray(g_Camera, ndc);

    float intersectionDistance;

    // Really the plan should be hitting here, since we already know the triangle was rendered by the rasterizer, we
    // mostly want to calculate at what distance it does
    if (!distance_from_triangle_plane(cameraRay, triangleWS, intersectionDistance))
    {
        return false;
    }

    positionWS = ray_point_at(cameraRay, intersectionDistance);
    barycentric_calculate(bc, triangleWS.v, positionWS);

    const ecs_entity entity = OBLO_INSTANCE_DATA(vb.instanceTableId, i_EntityIdBuffer, vb.instanceId);

    // #if OBLO_DEBUG_PRINTF
    //     if (entity.id > 3)
    //     {
    //         debugPrintfEXT("[TILING] Entity: %d [instance: %d %d]\n", spawnData.entity.id, vb.instanceTableId,
    //         vb.instanceId);
    //     }
    // #endif

    spawnData.entity = entity;
    spawnData.packedMeshletAndTriangleId = visibility_buffer_get_packed_meshlet_ids(visBufferData.xy);
    spawnData.barycentricU = bc.lambda.x;
    spawnData.barycentricV = bc.lambda.y;

    return all(greaterThanEqual(bc.lambda, vec3(0)));
}