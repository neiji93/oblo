#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_buffer_reference : require
#extension GL_ARB_gpu_shader_int64 : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_control_flow_attributes : require

#define SURFEL_POOL_BINDING 33
#define SURFEL_POOL_QUALIFIER readonly

#include <renderer/debug/printf>
#include <renderer/instances>
#include <renderer/math>
#include <renderer/meshes/mesh_attributes>
#include <renderer/meshes/mesh_data>
#include <renderer/meshes/mesh_indices>
#include <renderer/meshes/mesh_table>
#include <renderer/transform>
#include <surfels/surfel>
#include <surfels/surfel_grid_r>
#include <surfels/surfel_pool>
#include <visibility/visibility_buffer>
#include <visibility/visibility_utils>

const uint g_TileSize = 16;

layout(std430, binding = 0) restrict writeonly buffer b_OutTileCoverage
{
    surfel_tile_data g_TileData[];
};

layout(binding = 10, rg32ui) uniform restrict readonly uimage2D t_InVisibilityBuffer;

layout(binding = 16) uniform b_CameraBuffer
{
    camera_buffer g_Camera;
};

layout(local_size_x = g_TileSize, local_size_y = g_TileSize, local_size_z = 1) in;

shared float g_PixelCoverage[16][16];

bool read_geometry(in ivec2 screenPos, in uvec2 resolution, out vec3 positionWS, out vec3 normalWS);

void main()
{
    const ivec2 screenPos = ivec2(gl_WorkGroupID.xy * gl_WorkGroupSize.xy + gl_LocalInvocationID.xy);
    const uvec2 resolution = imageSize(t_InVisibilityBuffer);

    if (screenPos.x >= resolution.x || screenPos.y >= resolution.y)
    {
        return;
    }

    // When nothing is in the visibility buffer, we will fall back to the skybox. These pixels should not really matter
    // for the coverage, for now we assign an arbitrary coverage though.
    float coverage = 0.f;
    uint coverageSum = 0;
    uint pixelsWithFragments = 0;
    vec3 positionWS;
    vec3 normalWS;

    const bool hasGeometry = read_geometry(screenPos, resolution, positionWS, normalWS);

    if (hasGeometry)
    {
        const surfel_grid_header gridHeader = g_SurfelGridHeader;

        const ivec3 cell = surfel_grid_find_cell(gridHeader, positionWS);

        // Search neighboring cells and accumulate overlapping surfels

        uint overlappingSurfels = 0;

        [[unroll]] for (int x = -1; x <= 1; ++x)
        {
            [[unroll]] for (int y = -1; y <= 1; ++y)
            {
                [[unroll]] for (int z = -1; z <= 1; ++z)
                {
                    const ivec3 current = cell + ivec3(x, y, z);

                    if (surfel_grid_has_cell(gridHeader, current))
                    {
                        const uint index = surfel_grid_cell_index(gridHeader, current);
                        const surfel_grid_cell cellData = g_SurfelGridCells[index];

                        // TODO: Get all surfels and accumulate
                        const uint surfelsCount = cellData.surfelsCount;

                        // if (debug_is_center(screenPos, resolution))
                        // {
                        //     printf_vec3("Cell: ", vec3(current));
                        //     printf_uint("Cell Index: ", index);
                        //     printf_uint("FIRST ID: ", firstSurfel);
                        // }

                        for (uint cellSurfelIndex = 0; cellSurfelIndex < surfelsCount; ++cellSurfelIndex)
                        {
                            const uint surfelId = cellData.surfels[cellSurfelIndex];

                            if (debug_is_center(screenPos, resolution))
                            {
                                printf_uint("ID: ", surfelId);
                            }

                            const surfel_data surfel = g_SurfelData[surfelId];

                            // We should instead probably weigh by distance, but for now we just add 1 if it's in range
                            overlappingSurfels += uint(surfel_affects(surfel, positionWS));
                        }
                    }
                }
            }

            coverage = float(overlappingSurfels);

            coverageSum += overlappingSurfels;
            ++pixelsWithFragments;
        }

        // if (debug_is_center(screenPos, resolution))
        // {
        //     printf_uint("Affecting surfels: ", overlappingSurfels);
        // }
    }

    g_PixelCoverage[gl_LocalInvocationID.y][gl_LocalInvocationID.x] = coverage;

    memoryBarrierShared();
    barrier();

    uvec2 worstCoverageID = uvec2(0, 0);

    // We could make better use of threads, but for now just let the first thread do the max

    float worstCoverage = g_PixelCoverage[0][0];

    for (uint i = 0; i < g_TileSize; ++i)
    {
        for (uint j = 0; j < g_TileSize; ++j)
        {
            const float pixelCoverage = g_PixelCoverage[i][j];

            if (pixelCoverage < worstCoverage)
            {
                worstCoverage = pixelCoverage;
                worstCoverageID = uvec2(i, j);
            }
        }
    }

    if (gl_LocalInvocationID.xy == worstCoverageID)
    {
        const float NO_SURFELS_NEEDED = 100000.f;

        // TODO: Write output
        const uint globalIndex = gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.x;

        // debugPrintfEXT("%u, %u -> %u\n", gl_WorkGroupID.x, gl_WorkGroupID.y, globalIndex);

        surfel_tile_data tileData;
        tileData.position = positionWS;
        tileData.normal = normalWS;

        // We don't need to spawn surfels if the tile only has skybox
        tileData.coverage = pixelsWithFragments == 0 ? NO_SURFELS_NEEDED : float(coverageSum) / pixelsWithFragments;

        if (gl_WorkGroupID.xy == uvec2(60, 31))
        {
            // printf_text("OK");
            // printf_uint("Index: ", globalIndex);
            // printf_uint("Index: ", globalIndex);
            // printf_uvec2("WKS: ", gl_WorkGroupSize);
        }

        g_TileData[globalIndex] = tileData;
    }
}

bool read_geometry(in ivec2 screenPos, in uvec2 resolution, out vec3 positionWS, out vec3 normalWS)
{
    // Parse the visibility buffer to find which triangle we are processing
    const uvec4 visBufferData = imageLoad(t_InVisibilityBuffer, screenPos);

    visibility_buffer_data vb;

    if (!visibility_buffer_parse(visBufferData.xy, vb))
    {
        return false;
    }

    // Read the instance data we need
    const mesh_handle mesh = OBLO_INSTANCE_DATA(vb.instanceTableId, i_MeshHandles, vb.instanceId);
    const transform transform = OBLO_INSTANCE_DATA(vb.instanceTableId, i_TransformBuffer, vb.instanceId);

    triangle triangleWS;
    vec3 triangleNormal[3];

    // Read the mesh data
    const mesh_table meshTable = mesh_table_fetch(mesh);
    const uvec3 vertexIndices = mesh_get_meshlet_indices(meshTable, mesh, vb.meshletId, vb.meshletTriangleId);

    // Read the vertex data and transform everything in world space, we do lighting calculation in that space
    [[unroll]] for (uint i = 0; i < 3; ++i)
    {
        const uint vertexId = vertexIndices[i];

        const vec3 vertexPosition = mesh_get_position(meshTable, vertexId);
        triangleWS.v[i] = (transform.localToWorld * vec4(vertexPosition, 1)).xyz;

        const vec3 vertexNormal = mesh_get_normal(meshTable, vertexId);
        triangleNormal[i] = vertexNormal;
    }

    barycentric_coords bc;

    // Cast a ray from the camera to the near plane and calculate the distance of the ray hit to the plane on the
    // triangle in world space, we use that to derive the position in world space
    const vec2 ndc = screen_to_ndc(screenPos, resolution);
    const ray cameraRay = visibility_calculate_camera_ray(g_Camera, ndc);

    float intersectionDistance;

    // Really the plan should be hitting here, since we already know the triangle was rendered by the rasterizer, we
    // mostly want to calculate at what distance it does
    if (!distance_from_triangle_plane(cameraRay, triangleWS, intersectionDistance))
    {
        return false;
    }

    positionWS = ray_point_at(cameraRay, intersectionDistance);

    barycentric_calculate(bc, triangleWS.v, positionWS);

    const vec3 normal = barycentric_interpolate(bc, triangleNormal);
    normalWS = (transform.normalMatrix * vec4(normal, 1)).xyz;

    return true;
}