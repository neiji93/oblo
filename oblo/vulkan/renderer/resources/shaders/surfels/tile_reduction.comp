#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_buffer_reference : require
#extension GL_ARB_gpu_shader_int64 : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_control_flow_attributes : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_ballot : require

#include <renderer/debug/printf>
#include <surfels/surfel_data>

layout(std430, binding = 0) restrict readonly buffer b_InBuffer
{
    surfel_tile_data g_InBuffer[];
};

layout(std430, binding = 1) restrict writeonly buffer b_OutBuffer
{
    surfel_tile_data g_OutBuffer[];
};

uint find_lowest_within_subgroup(in float value)
{
    const float lowestCoverage = subgroupMin(value);
    const bool isBestCandidate = lowestCoverage == value;
    const uvec4 bestCandidateBallot = subgroupBallot(isBestCandidate);
    return subgroupBallotFindLSB(bestCandidateBallot);
}

shared surfel_tile_data g_GroupCandidates[OBLO_SUBGROUP_SIZE];

layout(push_constant) uniform c_PushConstants
{
    uint srcElements;
}
g_Constants;

const uint g_GroupSize = OBLO_SUBGROUP_SIZE * OBLO_SUBGROUP_SIZE;
layout(local_size_x = g_GroupSize, local_size_y = 1, local_size_z = 1) in;

void main()
{
    const uint globalIndex = gl_GlobalInvocationID.x;

    surfel_tile_data tileData;

    if (globalIndex < g_Constants.srcElements)
    {
        tileData = g_InBuffer[globalIndex];
    }
    else
    {
        tileData.spawnData = surfel_spawn_data_invalid();
        tileData.coverage = NO_SURFELS_NEEDED;
    }

    const uint bestSubgroupCandidateIdx = find_lowest_within_subgroup(tileData.coverage);

    if (gl_SubgroupInvocationID == bestSubgroupCandidateIdx)
    {
        const uint localOutputIndex = gl_LocalInvocationID.x / OBLO_SUBGROUP_SIZE;
        g_GroupCandidates[localOutputIndex] = tileData;
    }

    subgroupMemoryBarrierShared();
    memoryBarrierShared();
    barrier();

    // We only keep the first subgroup active now, to perform another round of reduction
    if (gl_SubgroupID > 0)
    {
        return;
    }

    tileData = g_GroupCandidates[gl_SubgroupInvocationID];
    const uint bestGroupCandidateIdx = find_lowest_within_subgroup(tileData.coverage);

    if (gl_SubgroupInvocationID == bestGroupCandidateIdx)
    {
        const uint outputIndex = gl_WorkGroupID.x;
        g_OutBuffer[outputIndex] = tileData;

// #if OBLO_DEBUG_PRINTF
//         if (g_Constants.srcElements < 10)
//         {
//             debugPrintfEXT("Best coverage: %f (%f %f %f)\n", tileData.coverage, tileData.position.x, tileData.position.t, tileData.position.z);
//         }
// #endif
    }
}